#!/usr/bin/env -S node --experimental-modules --no-warnings
'use strict';
import { Gearman as Rpc, RpcError } from '../lib/rpc.mjs';
import gear from '../lib/gear.mjs';
import log from '../lib/util/log.mjs';
import { worker as debug } from '../lib/util/debug.mjs';
import ms from 'ms';
import noop from '../lib/util/noop.mjs';
import yargs from 'yargs';
import chrono from 'chrono-node';
import child from 'child_process';

function wrap (fn) {
  return async (...args) => {
    try {
      await fn(...args);
    } catch (err) {
      log.crit(err);
    }
  };
}

const y = yargs
  .strict()
  .usage('Usage: $0 [options] <name/space::method> <command> [arguments...]')
  .option('concurrency', { alias: 'j', describe: 'how many jobs can run at the same time', type: 'number', default: 1 })
  .option('job-args', { alias: 'A', describe: 'handle job args', choices: ['stdin', 'append', 'prepend', 'ignore'], default: 'stdin' })
  .option('output', { alias: 'O', describe: 'handle command output', choices: ['string', 'buffer', 'json', 'nl-json'], default: 'string' })
  .option('quiet', { alias: 'q', describe: 'output minimally', type: 'boolean' });
const argv = y.argv;

if (argv._.length < 2) {
  y.showHelp();
  y.exit();
}

if (argv.quiet) log.quiet();

const [nsm, command, ...args] = argv._;

let [ns, method] = nsm.split('::', 2);
if (!method) {
  method = ns;
  ns = '';
}

const rpc = new Rpc(gear({
  maxJobs: argv.concurrency
}), {
  ns: ns.split(/[\/\\]/),
  methods: { [method]: work }
});

log.info(`=== Waiting for jobs...`);

function flatArgs (a) {
  if (Array.isArray(a)) {
    return a;
  } else if (typeof a === 'object') {
    return Object.entries(a).map(pair => pair.join('='));
  } else {
    return [`${a}`];
  }
}

function work (jobArgs, { meta: { gearbox_id: id } }) {
  const start = new Date;

  try {
    log.info(`==> Starting job (${id})`);

    let finalArgs = [];
    finalArgs.push(...args);

    const opts = {};

    switch (argv.jobArgs) {
      case 'ignore':
        break;

      case 'stdin':
        opts.input = JSON.stringify(jobArgs);
        break;

      case 'append':
        finalArgs.push(...flatArgs(jobArgs));
        break;

      case 'prepend':
        finalArgs = [];
        finalArgs.push(...flatArgs(jobArgs));
        finalArgs.push(...args);
        break;
    }

    finalArgs = finalArgs.map(a => `${a}`);
    debug(command, finalArgs);
    // TODO: use async so workers can work in parallel!
    let data = child.execFileSync(command, finalArgs, opts);
    debug(data);

    switch (argv.output) {
      case 'buffer':
        data = Buffer.from(data);
        break;

      case 'string':
        data = Buffer.from(data).toString();
        break;

      case 'json':
        data = JSON.parse(data);
        break;

      case 'nl-json':
        data = data.split(/[\r\n]/).map(d => JSON.parse(d));
        break;
    }

    debug(data);
    log.info(`<== Job ended successfully, sending output back`);
    setImmediate(() => rpc.notify('gearbox\\core::job_data', { id, data, status: 'complete' }));
  } catch (err) {
    let data;
    if (err.stderr || err.stdout || err.status) {
      data = {
        stderr: err.stderr,
        stdout: err.stdout,
        status: err.status,
      };
    } else if (err instanceof RpcError) {
      data = err.toJSON().error;
    } else {
      data = err.stack || err.toString();
    }

    log.info(`<== Job failed, sending error back`);
    setImmediate(() => rpc.notify('gearbox\\core::job_data', { id, data, status: 'errored' }));
  } finally {
    log.info('=== Took', ms(new Date - start));
  }
}
